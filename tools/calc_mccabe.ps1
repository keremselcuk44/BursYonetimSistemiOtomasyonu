param(
  [string]$Root = ".",
  [string]$OutCsv = "mccabe_complexity.csv",
  [string]$OutSummary = "mccabe_summary.md"
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function Get-ProjectName([string]$path) {
  if ($path -match "OgrenciBursOtomasyonu\.Api") { return "OgrenciBursOtomasyonu.Api" }
  if ($path -match "OgrenciBursOtomasyonu\.Desktop") { return "OgrenciBursOtomasyonu.Desktop" }
  return "Other"
}

function Strip-Code([string]$text) {
  # Removes comments (//, /* */) and string/char literals to reduce false keyword matches.
  $sb = New-Object System.Text.StringBuilder
  $i = 0
  $len = $text.Length
  $state = "code" # code | linecomment | blockcomment | string | char | verbatim

  while ($i -lt $len) {
    $c = $text[$i]
    $n = if ($i + 1 -lt $len) { $text[$i + 1] } else { [char]0 }

    switch ($state) {
      "code" {
        if ($c -eq "/" -and $n -eq "/") { $state = "linecomment"; $i += 2; continue }
        if ($c -eq "/" -and $n -eq "*") { $state = "blockcomment"; $i += 2; continue }
        if ($c -eq "@") {
          if ($n -eq '"') { $state = "verbatim"; $sb.Append(" "); $i += 2; continue }
        }
        if ($c -eq '"') { $state = "string"; $sb.Append(" "); $i++; continue }
        if ($c -eq "'") { $state = "char"; $sb.Append(" "); $i++; continue }
        $sb.Append($c) | Out-Null
        $i++
      }
      "linecomment" {
        if ($c -eq "`n") { $state = "code"; $sb.Append("`n") | Out-Null }
        $i++
      }
      "blockcomment" {
        if ($c -eq "*" -and $n -eq "/") { $state = "code"; $i += 2; continue }
        $i++
      }
      "string" {
        if ($c -eq "\" -and $n -ne [char]0) { $i += 2; continue } # skip escaped char
        if ($c -eq '"') { $state = "code"; $i++; continue }
        $i++
      }
      "char" {
        if ($c -eq "\" -and $n -ne [char]0) { $i += 2; continue }
        if ($c -eq "'") { $state = "code"; $i++; continue }
        $i++
      }
      "verbatim" {
        # verbatim strings end with " but "" is escaped quote inside
        if ($c -eq '"' -and $n -eq '"') { $i += 2; continue }
        if ($c -eq '"') { $state = "code"; $i++; continue }
        $i++
      }
    }
  }
  return $sb.ToString()
}

function Count-Regex([string]$text, [string]$pattern) {
  return ([regex]::Matches($text, $pattern)).Count
}

function Calc-Complexity([string]$methodBody) {
  $code = Strip-Code $methodBody
  # Decision points (approx):
  $ifCount = Count-Regex $code "\bif\b"
  $forCount = Count-Regex $code "\bfor\b"
  $foreachCount = Count-Regex $code "\bforeach\b"
  $whileCount = Count-Regex $code "\bwhile\b"
  $catchCount = Count-Regex $code "\bcatch\b"
  $caseCount = Count-Regex $code "\bcase\b"
  $andCount = Count-Regex $code "&&"
  $orCount = Count-Regex $code "\|\|"
  $ternaryCount = Count-Regex $code "\?"

  $decisions = $ifCount + $forCount + $foreachCount + $whileCount + $catchCount + $caseCount + $andCount + $orCount + $ternaryCount
  return [pscustomobject]@{
    Complexity = 1 + $decisions
    Decisions = $decisions
    If = $ifCount
    For = $forCount
    Foreach = $foreachCount
    While = $whileCount
    Catch = $catchCount
    Case = $caseCount
    AndAnd = $andCount
    OrOr = $orCount
    Ternary = $ternaryCount
  }
}

function Get-ClassNameFromContext([string[]]$lines, [int]$lineIdx) {
  for ($i = $lineIdx; $i -ge 0; $i--) {
    $line = $lines[$i]
    if ($line -match "^\s*(public|internal|private|protected)?\s*(partial\s+)?(class|record|struct)\s+(?<name>[A-Za-z_][A-Za-z0-9_]*)\b") {
      return $matches["name"]
    }
  }
  return ""
}

function Get-MethodNameFromSignature([string]$sig) {
  # Rough extraction: last identifier before '('
  if ($sig -match "(?<name>[A-Za-z_][A-Za-z0-9_]*)\s*\(") { return $matches["name"] }
  return ""
}

function Is-AutoGeneratedFile([string]$path) {
  if ($path -match "\\bin\\") { return $true }
  if ($path -match "\\obj\\") { return $true }
  if ($path -match "\\Migrations\\") { return $true }
  if ($path -match "\.Designer\.cs$") { return $true }
  if ($path -match "\.g(\.i)?\.cs$") { return $true }
  if ($path -match "AssemblyInfo\.cs$") { return $true }
  return $false
}

function Extract-Methods([string]$filePath) {
  $text = Get-Content -LiteralPath $filePath -Raw
  $lines = $text -split "`r?`n"
  $results = New-Object System.Collections.Generic.List[object]

  $depth = 0
  $inMethod = $false
  $methodStartLine = 0
  $methodSig = ""
  $methodDepthAtStart = 0
  $methodSb = $null

  for ($idx = 0; $idx -lt $lines.Length; $idx++) {
    $line = $lines[$idx]

    if (-not $inMethod) {
      # Heuristic: method signature line or multi-line signature ending with "{"
      if ($line -match "^\s*(public|private|protected|internal|static|virtual|override|sealed|async|new|partial|\s)+.*\)\s*(where\s+.*)?\s*\{\s*$" -and
          $line -notmatch "^\s*(if|for|foreach|while|switch|catch)\b") {
        $inMethod = $true
        $methodStartLine = $idx + 1
        $methodSig = $line.Trim()
        $methodDepthAtStart = $depth
        $methodSb = New-Object System.Text.StringBuilder
        $methodSb.AppendLine($line) | Out-Null
      }
      else {
        # not in method; update depth
        $open = ([regex]::Matches($line, "\{")).Count
        $close = ([regex]::Matches($line, "\}")).Count
        $depth += ($open - $close)
      }
    }
    else {
      $methodSb.AppendLine($line) | Out-Null

      $open = ([regex]::Matches($line, "\{")).Count
      $close = ([regex]::Matches($line, "\}")).Count
      $depth += ($open - $close)

      # method ends when we return to depth at start
      if ($depth -le $methodDepthAtStart) {
        $inMethod = $false
        $methodEndLine = $idx + 1
        $methodText = $methodSb.ToString()

        $className = Get-ClassNameFromContext $lines ($methodStartLine - 1)
        $methodName = Get-MethodNameFromSignature $methodSig
        if ([string]::IsNullOrWhiteSpace($methodName)) { $methodName = "<unknown>" }

        $metrics = Calc-Complexity $methodText
        $results.Add([pscustomobject]@{
          Project = Get-ProjectName $filePath
          File = $filePath
          Class = $className
          Method = $methodName
          StartLine = $methodStartLine
          EndLine = $methodEndLine
          Complexity = $metrics.Complexity
          Decisions = $metrics.Decisions
          If = $metrics.If
          For = $metrics.For
          Foreach = $metrics.Foreach
          While = $metrics.While
          Catch = $metrics.Catch
          Case = $metrics.Case
          AndAnd = $metrics.AndAnd
          OrOr = $metrics.OrOr
          Ternary = $metrics.Ternary
        }) | Out-Null
      }
    }
  }

  return $results
}

$rootPath = Resolve-Path -LiteralPath $Root
$csFiles = Get-ChildItem -LiteralPath $rootPath -Recurse -File -Filter *.cs |
  Where-Object { -not (Is-AutoGeneratedFile $_.FullName) }

$all = New-Object System.Collections.Generic.List[object]
foreach ($f in $csFiles) {
  try {
    $methods = Extract-Methods $f.FullName
    foreach ($m in $methods) { $all.Add($m) | Out-Null }
  } catch {
    Write-Warning "Failed parsing: $($f.FullName) - $($_.Exception.Message)"
  }
}

$allSorted = $all | Sort-Object Complexity -Descending

# Write CSV
$utf8Bom = New-Object System.Text.UTF8Encoding($true)

# Write CSV (UTF-8 BOM for Excel/Windows friendliness)
$csvLines = $allSorted | ConvertTo-Csv -NoTypeInformation
$csvText = ($csvLines -join "`r`n") + "`r`n"
[System.IO.File]::WriteAllText((Resolve-Path -LiteralPath $OutCsv), $csvText, $utf8Bom)

# Write markdown summary
$total = ($allSorted | Measure-Object).Count
$avg = if ($total -gt 0) { [Math]::Round((($allSorted | Measure-Object Complexity -Average).Average), 2) } else { 0 }
$max = if ($total -gt 0) { ($allSorted | Select-Object -First 1).Complexity } else { 0 }

$high = ($allSorted | Where-Object { $_.Complexity -ge 15 } | Measure-Object).Count
$mid = ($allSorted | Where-Object { $_.Complexity -ge 10 -and $_.Complexity -lt 15 } | Measure-Object).Count
$low = ($allSorted | Where-Object { $_.Complexity -lt 10 } | Measure-Object).Count

$topN = 25
$top = $allSorted | Select-Object -First $topN

$md = New-Object System.Text.StringBuilder
$md.AppendLine("## McCabe (Cyclomatic) KarmaÅŸÄ±klÄ±ÄŸÄ± Raporu") | Out-Null
$md.AppendLine("") | Out-Null
$md.AppendLine("**Tarih:** $(Get-Date -Format 'yyyy-MM-dd HH:mm')") | Out-Null
$md.AppendLine("") | Out-Null
$md.AppendLine("### Hesaplama YÃ¶ntemi") | Out-Null
$md.AppendLine('- Ã–lÃ§Ã¼t: YaklaÅŸÄ±k McCabe / Cyclomatic Complexity') | Out-Null
$md.AppendLine('- FormÃ¼l: **CC = 1 + karar_noktalarÄ±**') | Out-Null
$md.AppendLine('- Karar noktalarÄ± (sayÄ±m): `if`, `for`, `foreach`, `while`, `catch`, `case`, `&&`, `||`, ternary `?`') | Out-Null
$md.AppendLine('- HariÃ§ tutulan otomatik Ã¼retilen dosyalar: `bin/`, `obj/`, `Migrations/`, `*.Designer.cs`, `*.g.cs`, `AssemblyInfo.cs`') | Out-Null
$md.AppendLine("") | Out-Null
$md.AppendLine("### Ã–zet") | Out-Null
$md.AppendLine("- Toplam Ã¶lÃ§Ã¼len fonksiyon/metot: **$total**") | Out-Null
$md.AppendLine("- Ortalama karmaÅŸÄ±klÄ±k: **$avg**") | Out-Null
$md.AppendLine("- Maksimum karmaÅŸÄ±klÄ±k: **$max**") | Out-Null
$md.AppendLine("- DaÄŸÄ±lÄ±m: **<10:** $low, **10-14:** $mid, **>=15:** $high") | Out-Null
$md.AppendLine("") | Out-Null
$md.AppendLine("### En KarmaÅŸÄ±k Ä°lk $topN Fonksiyon") | Out-Null
$md.AppendLine("") | Out-Null
$md.AppendLine("| # | Proje | Dosya | SÄ±nÄ±f | Metot | SatÄ±r | CC |") | Out-Null
$md.AppendLine("|---:|---|---|---|---|---:|---:|") | Out-Null

$i = 1
foreach ($t in $top) {
  $shortFile = $t.File.Replace($rootPath.Path + "\", "")
  $range = "$($t.StartLine)-$($t.EndLine)"
  $md.AppendLine("| $i | $($t.Project) | $shortFile | $($t.Class) | $($t.Method) | $range | $($t.Complexity) |") | Out-Null
  $i++
}

[System.IO.File]::WriteAllText((Resolve-Path -LiteralPath $OutSummary), $md.ToString(), $utf8Bom)

Write-Host "Wrote: $OutCsv"
Write-Host "Wrote: $OutSummary"


